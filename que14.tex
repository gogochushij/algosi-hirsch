\section{(14) Рандомизированный QuickSort (Осипов Д.)}

В этой главе мы строго докажем, что матожидание времени работы рандомизированного Quicksort есть $O(n\log n)$.

(В чисто академических целях можно также представить его как алгоритм
с гарантированным [независимо от случайных чисел] временем работы
и ограниченной вероятностью ошибки ---
просто прервём его, если он не закончил свою работы
за $10Cn\log n$, где $C$ --- константа из $O(\ldots)$.
Требуемое утверждение получится по неравенству Маркова.)

Приведем реализацию Quicksort из книжки Cormen et al. Сортировка всего массива вызывается \texttt{Quicksort(A, 1, len(A))}.

\begin{algorithm}[H]
	\caption{Нижний текст}
	\DontPrintSemicolon
	\SetKwIF{If}{ElseIf}{Else}{if}{:}{elif}{else}{}
	\SetKwFor{For}{for}{:}{}
	\SetKwProg{Fn}{}{:}{}
	\SetKwFunction{partition}{Partition}
	\SetKwFunction{quicksort}{Quicksort}
	\SetKw{random}{random}
	\Fn{\partition{$A$, $p$, $r$}}{
		$i$ = \random $\in [p, r]$\;\label{alg:select-begin}
		$A[r] \leftrightarrow A[i]$\;
		$x$ = $A[r]$\;\label{alg:select-end}
		$i$ = $p-1$\;\label{alg:perm-begin}
		\For{$j$ = $p\ldots r-1$}{\label{alg:for-begin}
			\If{$A[j] \leq x$}{\label{alg:compare}
				$i$++\;
				$A[i] \leftrightarrow A[j]$\;\label{alg:perm-end}
			}
		}
		$A[i+1] \leftrightarrow A[r]$\;\label{alg:x-return}
		\KwRet $i+1$\;\label{alg:pos-return}
	}\;
	\Fn{\quicksort{$A$, $p$, $r$}}{
		\If {$p<r$}{
			$q$ = \partition{$A$, $p$, $r$}\;
			\quicksort{$A$, $p$, $q-1$}\;\label{alg:qsorts-begin}
			\quicksort{$A$, $q+1$, $r$}\;\label{alg:qsorts-end}
		}
	}
\end{algorithm}


Напомним, как работает процедура \texttt{Partition}. Она обрабатывает отрезок $[p\ldots r]$ массива $A$ следующим образом.  В строках~\ref{alg:select-begin}-\ref{alg:select-end} случайно выбирается \textit{опорный элемент}, который перемещается в конец отрезка и запоминается в $x$. В строках~\ref{alg:perm-begin}-\ref{alg:perm-end} элементы $[p\ldots r-1]$ меняются таким образом, что все элементы $\leq x$ расположены слева, а все элементы $> x$ справа. Строка~\ref{alg:x-return} располагает $x$ между этими частями (немного меняя правую часть). Таким образом, отрезок $A[p\ldots r]$ разбивается на три части: сначала идут элементы $\leq x$, потом сам $x$, потом $>x$. Строка~\ref{alg:pos-return} возвращает позицию $x$.

\begin{theorem*}
    Матожидание времени работы такого Quicksort есть $O(n\log n)$.
\end{theorem*}
\begin{proof}
    За $X$ обозначим случайную величину~-- общее число сравнений, произведенных на строке~\ref{alg:compare}, за все время выполнения \texttt{Quicksort(A, 1, len(A))}. Из строк~\ref{alg:qsorts-begin}-\ref{alg:qsorts-end} видно, что каждый вызов \texttt{Quicksort} <<убирает>> из работы один элемент массива, поэтому всего вызовов \texttt{Partition} не более $n$. Каждый вызов \texttt{Partition} совершает $O(1)$ действий плюс какое-то количество сравнений, так что суммарное время работы \texttt{Quicksort(A, 1, len(A))} есть $O(n+X)$.
    
    Нам нужно вычислить матожидание общего числа сравнений $\mathbb E X$. Переименуем элементы $A$ как $z_1 \leq \ldots \leq z_n$.
    
    Заметим, что любая пара элементов сравнивается не более одного раза. Действительно, при любом сравнении, как видно из строки~\ref{alg:compare}, один из двух сравниваемых элементов~-- опорный, и после окончания цикла (строка~\ref{alg:for-begin}) этот опорный элемент <<выпадает>> из работы и более ни с чем не сравнивается. Так что введем случайную величину $X_{ij} = [z_i, z_j \text{ когда-то сравнивались}]$. Ясно, что тогда:
    
    $$\mathbb E X = \mathbb E \sum_{i=1}^{n-1} \sum_{j=i+1}^n X_{ij} = \sum_{i=1}^{n-1} \sum_{j=i+1}^n \mathbb E X_{ij} = \sum_{i=1}^{n-1} \sum_{j=i+1}^n \mathbb P[z_i, z_j \text{ когда-то сравнивались}]$$.
    
    Осталось подсчитать $\mathbb P[z_i, z_j\text{ когда-то сравнивались}]$. Нужно выяснить, в каком случае $z_i$ и $z_j$ сравнятся, а в каких нет.
    
    Для примера рассмотрим массив, содержащий в каком-то порядке числа $\{1,2,3,4,5,6,7,8,9,10\}$. Пусть первым опорным элементом стала 7. Во-первых, это означает, что на данном этапе 7 сравнится со всеми остальными числами, а далее <<выпадет>> и ни с чем сравниваться не будет. Во-вторых, множество разбивается на две части $\{1,2,3,4,5,6\}$ и $\{8,9,10\}$ в том смысле, что все дальнейшие сравнения будут происходить \textbf{только} внутри этих частей. Например, 2 и 9 точно не сравнятся, а 2 и 4 могут сравниться (если не попадут в разные части на какой-нибудь из следующих итераций).
    
    В общем случае всё обстоит так: если какой-то элемент $x$ ($z_i \leq x \leq z_j$) был опорным до того, как опорными стали $z_i$ и $z_j$, то $z_i$ и $z_j$ не сравнятся. И наоборот~-- если ни один из элементов $z_i, z_{i+1},\ldots, z_j$ не стал опорным до того, как опорным стал $z_i$ или $z_j$, то $z_i$ и $z_j$ сравнятся.
    
    Итак, можно видеть, что $z_i$ и $z_j$ сравнятся тогда и только тогда, когда среди элементов $z_i, z_{i+1}, \ldots, z_j$ раньше всех опорным элементом станет либо $z_i$, либо $z_j$. Вероятность этого равна $\frac{2}{j-i+1}$.
    
    Имеем: $$\mathbb E X = \sum_{i=1}^{n-1} \sum_{j=i+1}^n \frac{2}{j-i+1}$$
    
    Замена переменных во внутренней сумме $k = j-i$ дает:
    
    $$ = \sum_{i=1}^{n-1} \sum_{k=1}^{n-i} \frac{2}{k+1} < \sum_{i=1}^n \sum_{k=1}^n \frac{2}{k} = \sum_{i=1}^n O(\log n) = O(n \log n)$$
    
    Таким образом, матожидание времени работы \texttt{Quicksort} есть $O(n+n\log n) = O(n\log n)$. 
\end{proof}

На самом деле мы могли бы вместо вероятностного варианта Quicksort рассмотреть обычный детерминированный (вместо рандомизированного выбора элемента брать, например, всегда просто первый элемент). Как мы знаем, он работает квадратичное время на некоторых массивах, но среднее (по входным данным! алгоритм не использует случайных чисел!) время работы будет $O(n\log n)$ (упражнение). Вероятностный вариант лучше такого вот детерминированного тем, что время работы вероятностного Quicksort на конкретном массиве не зависит от этого массива, а зависит только от попавшихся ему случайных чисел.