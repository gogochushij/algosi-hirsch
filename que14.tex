\section{(14) Рандомизированный QuickSort (Осипов Д.)}

В этой главе мы строго докажем, что среднее время (матожидание времени) работы рандомизированного Quicksort есть $O(n\log n)$.

Приведем его реализацию (Cormen). Сортировка всего массива вызывается \texttt{Quicksort(A, 1, len(A))}.

\begin{algorithm}[H]
	\caption{Нижний текст}
	\DontPrintSemicolon
	\SetKwIF{If}{ElseIf}{Else}{if}{:}{elif}{else}{}
	\SetKwFor{For}{for}{:}{}
	\SetKwProg{Fn}{}{:}{}
	\SetKwFunction{partition}{Partition}
	\SetKwFunction{quicksort}{Quicksort}
	\SetKw{random}{random}
	\Fn{\partition{$A$, $p$, $r$}}{
		$i$ = \random $\in [p, r]$\;\label{alg:select-begin}
		$A[r] \leftrightarrow A[i]$\;
		$x$ = $A[r]$\;\label{alg:select-end}
		$i$ = $p-1$\;\label{alg:perm-begin}
		\For{$j$ = $p\ldots r-1$}{\label{alg:for-begin}
			\If{$A[j] \leq x$}{\label{alg:compare}
				$i$++\;
				$A[i] \leftrightarrow A[j]$\;\label{alg:perm-end}
			}
		}
		$A[i+1] \leftrightarrow A[r]$\;\label{alg:x-return}
		\KwRet $i+1$\;\label{alg:pos-return}
	}\;
	\Fn{\quicksort{$A$, $p$, $r$}}{
		\If {$p<r$}{
			$q$ = \partition{$A$, $p$, $r$}\;
			\quicksort{$A$, $p$, $q-1$}\;\label{alg:qsorts-begin}
			\quicksort{$A$, $q+1$, $r$}\;\label{alg:qsorts-end}
		}
	}
\end{algorithm}


Напомним, как работает процедура \texttt{Partition}. Она обрабатывает отрезок $[p\ldots r]$ массива $A$ следующим образом.  В строках~\ref{alg:select-begin}-\ref{alg:select-end} случайно выбирается \textit{опорный элемент}, который перемещается в конец отрезка и запоминается в $x$. В строках~\ref{alg:perm-begin}-\ref{alg:perm-end} элементы $[p\ldots r-1]$ меняются таким образом, что все элементы $\leq x$ расположены слева, а все элементы $> x$ справа. Строка~\ref{alg:x-return} располагает $x$ между этими частями (немного меняя правую часть). Таким образом, отрезок $A[p\ldots r]$ разбивается на три части: сначала идут элементы $\leq x$, потом сам $x$, потом $>x$. Строка~\ref{alg:pos-return} возвращает позицию $x$.

\underline{Итак, считаем среднее время}. За $X$ обозначим случайную величину~-- общее число сравнений, произведенных на строке~\ref{alg:compare}, за все время выполнения \texttt{Quicksort(A, 1, len(A))}. Из строк~\ref{alg:qsorts-begin}-\ref{alg:qsorts-end} видно, что каждый вызов \texttt{Quicksort} <<убирает>> из работы один элемент массива, поэтому всего вызовов \texttt{Partition} не более $n$. Каждый вызов \texttt{Partition} совершает $O(1)$ действий плюс какое-то количество сравнений, так что суммарное время работы \texttt{Quicksort(A, 1, len(A))} есть $O(n+X)$.

Нам нужно вычислить матожидание общего числа сравнений $\mathbb E X$. Переименуем элементы $A$ как $z_1 \leq \ldots \leq z_n$.

Заметим, что любая пара элементов сравнивается не более одного раза. Действительно, при любом сравнении, как видно из строки~\ref{alg:compare}, один из двух сравниваемых элементов~-- опорный, и после окончания цикла (строка~\ref{alg:for-begin}) этот опорный элемент <<выпадает>> из работы и более ни с чем не сравнивается. Так что введем случайную величину $X_{ij} = [z_i, z_j \text{ когда-то сравнивались}]$. Ясно, что тогда:

$$\mathbb E X = \mathbb E \sum_{i=1}^{n-1} \sum_{j=i+1}^n X_{ij} = \sum_{i=1}^{n-1} \sum_{j=i+1}^n \mathbb E X_{ij} = \sum_{i=1}^{n-1} \sum_{j=i+1}^n \mathbb P[z_i, z_j \text{ когда-то сравнивались}]$$.

Осталось подсчитать $\mathbb P[z_i, z_j\text{ когда-то сравнивались}]$. Нужно выяснить, в каком случае $z_i$ и $z_j$ сравнятся, а в каких нет.

Для примера рассмотрим массив, содержащий в каком-то порядке числа $\{1,2,3,4,5,6,7,8,9,10\}$. Пусть первым опорным элементом стала 7. Во-первых, это означает, что на данном этапе 7 сравнится со всеми остальными числами, а далее <<выпадет>> и ни с чем сравниваться не будет. Во-вторых, множество разбивается на две части $\{1,2,3,4,5,6\}$ и $\{8,9,10\}$ в том смысле, что все дальнейшие сравнения будут происходить \textbf{только} внутри этих частей. Например, 2 и 9 точно не сравнятся, а 2 и 4 могут сравниться (если не попадут в разные части на какой-нибудь из следующих итераций).

В общем случае всё обстоит так: если какой-то элемент $x$ ($z_i \leq x \leq z_j$) был опорным до того, как опорными стали $z_i$ и $z_j$, то $z_i$ и $z_j$ не сравнятся. И наоборот~-- если ни один из элементов $z_i, z_{i+1},\ldots, z_j$ не стал опорным до того, как опорным стал $z_i$ или $z_j$, то $z_i$ и $z_j$ сравнятся.

Итак, можно видеть, что $z_i$ и $z_j$ сравнятся тогда и только тогда, когда среди элементов $z_i, z_{i+1}, \ldots, z_j$ раньше всех опорным элементом станет либо $z_i$, либо $z_j$. Вероятность этого равна $\frac{2}{j-i+1}$.

Имеем: $$\mathbb E X = \sum_{i=1}^{n-1} \sum_{j=i+1}^n \frac{2}{j-i+1}$$

Замена переменных во внутренней сумме $k = j-i$ дает:

$$ = \sum_{i=1}^{n-1} \sum_{k=1}^{n-i} \frac{2}{k+1} < \sum_{i=1}^n \sum_{k=1}^n \frac{2}{k} = \sum_{i=1}^n O(\log n) = O(n \log n)$$

Таким образом, матожидание времени работы \texttt{Quicksort} есть $O(n+n\log n) = O(n\log n)$. \qed
