\section{Параллельные алгоритмы -- iii (Осипов Д., \groth)}
\newcommand{\nxt}[1] {\mathtt{next[#1]}}
\newcommand{\nil} {\mathtt{nil}}
\subsection{(В РАЗРАБОТКЕ) Параллельное вычисление всех расстояний до конца списка}
\begin{problem}
Дан список $a_1, ..., a_n$  в следующем формате. Про каждый элемент $a_i$ известно, какой элемент за ним следует. Обозначим его номер за $\nxt{i}$. Если за элементом ничего не следует, считаем $\nxt{i} == \nil$. Предположим, что указатели $\nxt{i}$ действительно образуют список. Найти расстояние до конца списка для каждого элемента.
\end{problem}
У нее есть решение за $O(\log n)$.

Каждому элементу $a_i$ сопоставим процессор $p_i$. Заведем массив $d_i$, проинициализируем его следующим образом. На первом параллельном шаге для концевого $i$ ($next[i]==\nil$) положим $d_i = 0$, для всех остальных положим $d_i = 1$. В дальнейшем указатели будут изменяться (таким образом, структура списка будет нарушаться), и тогда $d_i$ будет означать расстояние между $a_i$ и $a_{next[i]}$ \underline{в исходном списке}.

Далее на каждом параллельном шаге происходит пересчет расстояний. Именно, каждый процессор $\mathtt i$, для которого $\nxt{i} \neq \nil$, делает следующее (порядок важен!): запоминает $d[\nxt{i}]$, затем увеличивает $d[i]$ на запомненное значение. После этого (снова порядок важен!) процессор $\mathtt i$ запоминает $\nxt{\nxt{i}}$, затем присваивает это значение к $\nxt{i}$. Алгоритм останавливается, когда все $\nxt{i} == \nil$. Описание алгоритма закончено.

Алгоритм корректно находит ответ. Действительно, только что описанный цикл сохраняет инвариант <<$d_i$ -- расстояние между $a_i$ и $a_{next[i]}$ в исходном списке>>, а в конце алгоритма все $next[i] == \nil$. 

Про корректность обращений к памяти читайте Cormen'а, я нифига не понимаю, наверное это и не нужно?????

Время работы алгоритма $O(\log n)$. Это следует из того, что начальная инициализация и каждая итерация цикла проходят за $O(1)$ времени, а сам цикл выполняется $\log n$ раз: все значения, для которых ?????.\qed

\subsection{(В РАЗРАБОТКЕ) Параллельное вычисление всех глубин дерева}
\statement{Задача. }{Дано подвешенное неориентированное дерево на $n$ вершинах, занумерованных $\{0,...,n-1\}$ в следующем формате. Имеются три массива $left[0..n-1], right[0..n-1], parent[0..n-1]$, для каждого $i$ $left[i], right[i] \text{ и } parent[i]$ суть номера левого потомка, правого потомка, родителя вершины $i$ (при отсутствии какого-то из параметров присвоено $\nil$). Предположим, что эти массивы действительно задают дерево. Вычислить глубины всех вершин относительно корня.}

\statement{Решение за $O(\log n)$ независимо от высоты дерева.}{} Сопоставим каждой вершине $i$ три процессора $A_i, B_i, C_i$. Перестроим дерево в ориентированный граф, вершины которого будут этими процессорами. Именно, проведем ребро:
\begin{itemize}
\item $A_i \rightarrow A_{left[i]}$, либо $A_i \rightarrow B_i$, если $left[i] == \nil$;
\item $B_i \rightarrow A_{right[i]}$, либо $B_i \rightarrow C_i$, если $right[i] == \nil$;
\item $C_i \rightarrow ...$
\begin{itemize}
\item $...B_{parent[i]}$, если $i$ -- левый потомок,
\item $...C_{parent[i]}$, если $i$ -- правый потомок,
\item либо $...\nil$, если $parent[i] == \nil$ ($i$ -- корень) (можно, наверное, считать, что у корневой вершины нет процессора $C$).
\end{itemize}
\end{itemize}

Можно проверить\footnote{Например, вспомнить критерий полуэйлеровости: для всех вершин $v$, кроме двух, $in(v) = out(v)$, а для особых двух вершин $in(v_1) = out(v_1) + 1$ и $in(v_2) = out(v_2) - 1$.}, что у этого графа существует эйлеров обход, начинающийся в $A$ корня и заканчивающийся в $C$ корня.

?????
