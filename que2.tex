\section{Параллельные алгоритмы~-- ii}

\secauthor{\denis}

\subsection{Параллельное вычисление всех префиксных сумм}\label{parallel_sums}
\begin{problem*}
	Дан массив $A[0\ldots n-1]$. Вычислить все его префиксные суммы, т.е. суммы вида $A[0]+A[1]+\ldots+A[i]$.
\end{problem*}

Мы не будем использовать ничего, кроме ассоциативности операции $+$, так что наш алгоритм можно будет использовать и для любой другой ассоциативной операции.

\begin{algodescription}{Решение за $O(\log n)$} Рекурсивный алгоритм. Предположим, что умеем считать префиксные суммы массивов меньшего размера.

Заведем вспомогательный массив $B[0\ldots \frac{n}{2}-1]$, в котором положим $B[i]=A[2i]+A[2i+1]$ (один параллельный шаг). Посчитаем (по предположению) все префиксные суммы $B$ и заменим ими сам массив $B$. После этой операции для всякого $0 \leq k \leq \frac{n}{2}-1$ верно $B[k] = \sum_{j=0}^{2k+1} A[j]$.

Теперь делаем на месте $A$ массив префиксных сумм $A$ следующим образом. Если $i > 0$ четное, то полагаем $A[i] = B[\frac{i}{2}-1] + A[i]$ (проверьте подстановкой, что $=\sum_{j=0}^{i}A[j]$). Если же $i > 0$ нечетное, то просто полагаем $A[i] = B[\frac{i-1}{2}]$ (снова проверьте, что $=\sum_{j=0}^{i}A[j]$). Эта операция~-- снова один параллельный шаг. Таким образом, на месте массива $A$ был построен массив префиксных сумм $A$.
\end{algodescription}

Соответствующий псевдокод:

\begin{algorithm}[H]
	\DontPrintSemicolon
	\SetKwIF{If}{ElseIf}{Else}{if}{:}{elif}{else}{}
	\SetKwFor{For}{for}{:}{}
	\SetKwProg{Fn}{}{:}{}
	\SetKwFunction{PrefixSum}{PrefixSum}
	\SetKw{Parallel}{parallel}
	\SetKw{Random}{random}
	\Fn{\PrefixSum{$\&A[0\ldots n-1]$}}{
		\If{$n>1$}{
			B = $[0]*\left(\frac{n}{2}-1\right)$ \\
			\Parallel \For{$i = 0\ldots\left(\frac{n}{2}-1\right)$}{
				B$[i]$ = A$[2i]$ + A$[2i+1]$\;
			}\;
			\PrefixSum{\textup{B}}\;\;
			\Parallel \For{$i = 0\ldots(n-1)$}{
				\eIf{$i$ четное}{
					A$[i]$ = B$\left[\frac{i}{2}-1\right]$ + A$[i]$\;
				}{
					A$[i]$ = B$\left[\frac{i-1}{2}\right]$\;
				}
			}
		}
	}
\end{algorithm}

\underline{Время работы} оценивается просто: из кода следует соотношение $T(n) = T(n/2) + C$, и далее можно написать $= T(n/4) + 2C = T(n/8) + 3C = \ldots = C\cdot\log n = O(\log n)$. \underline{Общая работа}: $W(n) = W(n/2) + O(n)$, откуда по мастер-теореме $W(n) = O(n)$. По принципу Брента количество процессоров можно взять $P(n) = \frac{W(n)}{T(n)} = O\left(\frac{n}{\log n}\right)$. \qed

\subsection{Параллельное сложение чисел}
\begin{problem*}Даны два (длинных) двоичных числа в виде $a = \sum_{i=0}^n a_i2^i$ и $b = \sum_{i=0}^n b_i2^i$. Вычислить их сумму в виде $c = \sum_{i=0}^n c_i2^i$.
\end{problem*}

\begin{algodescription}{Решение за $O(\log n)$}
    Для удобства считаем $a_n = b_n = 0$, остальные $a_i, b_i = 0\text{ или }1$

\underline{Формализуем алгоритм сложения столбиком.} Через $z_i$ обозначим число (0 или 1), которое при сложении столбиком переносится из $i$-того разряда в $(i+1)$-тый. Если бы мы знали все переносы $z_i$, то $c_i$ можно бы было вычислить по формуле\footnote{Полагая $z_{-1}=0$ по определению} $c_i = (a_i+b_i+z_{i-1})\%2$.

Положим:
\begin{itemize}
\item $g_i = a_i \land b_i$~-- <<\underline{г}енератор переноса>>,
\item $p_i = a_i \lor b_i$~-- <<\underline{п}родолжатор переноса>>.
\end{itemize}
Перебирая все возможные случаи, когда в $i$-том разряде может возникнуть перенос, получаем формулу для $z_i$ (опустим знак $\land$ для наглядности):
$$z_i = g_i \lor p_i z_{i-1}$$
Обратите внимание, что это похоже на <<линейную рекурренту>> на $z_i$. Распишем дальше $z_{i-1}$:
$$z_i = g_i \lor p_i(g_{i-1} \lor p_{i-1} z_{i-2})$$ $$ =g_i \lor p_i g_{i-1} \lor p_i p_{i-1} z_{i-2}$$
Итак, при одной <<итерации>> <<свободный член>> $g_i$ заменился на $g_i \lor p_i g_{i-1}$, а <<коэффициент>> $p_i$~-- на $p_i p_{i-1}$.
Определим операцию на парах битов: $$(a,b) \odot (a', b') = (a' \lor b' a, \;b' b)$$
Поверим \textbf{(нужно уметь проверять!)}, что эта операция ассоциативна.
Тогда если умеем вычислять вектора $$(v_{k1}, v_{k2}) = (0, 0)\odot (g_1, p_1)\odot (g_2, p_2)\odot \cdots \odot (g_k, p_k) \text{ для всех } k=1\ldots n,$$ то имеем $z_k = v_{k1} \lor v_{k2}z_{-1} = v_{k1}$. Но вектора $(v_{k1}, v_{k2})$ суть просто префиксные <<суммы>> последовательности $(0, 0), (g_1, p_1), \ldots, (g_n, p_n)$ относительно ассоциативной операции $\odot$. К ним применим алгоритм нахождения префиксных сумм за $O(\log n)$ выше.

\underline{Время и работа алгоритма}: сначала посчитали $g_i$ и $p_i$ за время $O(1)$ и работу $O(n)$, потом префиксы за $O(\log n)$ и работу $O(n)$, наконец вычислили $z_i$ и $c_i$ за время $O(1)$  и работу $O(n)$. Итоговое время $O(\log n)$, итоговая работа $O(n)$, процессоров $O\left(\frac{n}{\log n}\right)$.
\end{algodescription}

\subsection{Параллельное умножение чисел}
\begin{problem*}
	Даны два (длинных) двоичных числа в виде $a = \sum_{i=0}^n a_i 2^i$ и $b = \sum_{i=0}^n b_i 2^i$. Вычислить их произведение в виде $c = \sum_{i=0}^{2n} c_i 2^i$.
\end{problem*}

\begin{algodescription}{Решение за $O(\log n)$}
    Ясно, что $ab = \underset{i=0}{\overset{n}{\sum}}a b_i 2^i = \underset{i: \, b_i=1}{\sum} a 2^i$. Таким образом мы свели умножение двух чисел с сложению не более чем $n$ чисел. Но на этом не все.

\underline{Трюк <<Два по цене трёх>>}. Пусть нам даны три числа $x, y, z$. Как за $O(1)$ времени сделать из них два числа с той же суммой? Для каждого $i$ число $x_i + y_i + z_i$ есть некоторое двубитовое число $2p_i + q_i$. Составим числа $p,q$ из таких $p_i, q_i$. Тогда верно $x+y+z = 2p+q$. Итак, мы свели сложение трех чисел к сложению двух чисел за $O(1)$ времени\footnote{Именно $O(1)$, так как мы разобрались с каждым из $n$ битов по отдельности. Ни о каких <<переносах>> и сложении длинных чисел здесь речи не идет.} и $O(n)$ работы.

Итак, \underline{как быстро складывать много чисел?} Разбиваем их на тройки (возможные лишние 1-2 числа игнорируем), применяем к каждой тройке трюк. Делаем так, пока не останется одно или два числа (в последнем случае просто сложим их).

\underline{Оценим время и работу.} Один трюк требует $O(1)$ времени и $O(n)$ работы. На каждом параллельном шаге трюк применяется $\sim n/3 = O(n)$ раз, т.е. общая работа на одном параллельном шаге $O(n^2)$. На каждом шаге количество чисел уменьшается в $3/2$ раза, откуда $T(n) = T\left(\frac{n}{3/2}\right) + O(1)$ и $W(n) = W\left(\frac{n}{3/2}\right) + O(n^2)$. По мастер-теореме получаем $T(n) = O(\log_{3/2}n) = O(\log n)$ и $W(n) = O(n^2)$.\footnote{Оценка из <<Computational Complexity>> Пападимитроу $W(n) = O(n^2\log n)$ тоже верна, но грубее.} Процессоров можно брать $O\left(\frac{n^2}{\log n}\right)$.
\end{algodescription}
