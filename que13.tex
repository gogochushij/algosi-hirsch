\hypertarget{Рабин-Карп}{\section{Вероятностный алгоритм для сравнения строк на расстоянии и алгоритм Рабина-Карпа.}}

\statement{Вероятностный алгоритм для сравнения строк}{\\Под "на расстоянии" имеется в виду, что мы хотим потратить как можно меньше памяти на сравнение этих строк.}

Есть две строчки a и b длины n над \{0;1\}, хотим их сравнить. Выберем случайное простое число p от 3 до $\tau$, сравним остатки(a и b отождествим с числами, которые они задают при переводе в 10-ю систему счисления) от деления на p. Посмотрим на вероятность того что $a\neq b,$ но $a\mod{p}=b\mod{p}$. Коли сравнивать мы будем числа по модулю $p$, нам потребуется только $O(\log p)$ памяти на хранение двух остатков.
Плохие числа - это \{$p\in\mathbb{P} | (a-b)\vdots p$\}.
\\\statement{Лемма}{У числа $k\le 2^n$ меньше n различных простых делителей(очевидно)}
\\Пусть $\tau=n^2 \log^2(n)$; очевидно, $a-b\le 2^n$, тогда $P_{\text{ошибки}}\le\frac{n}{\frac{\tau}{\log\tau}}=O(\frac{1}{n})$. Здесь мы пользуемся ослабленной версией PNT: $\lim_{n\to\infty} \frac{\pi(n)}{\frac{n}{\log n}}=1$.
\\
\\
\statement{Алгоритм Рабина-Карпа}{Есть две строчки, $|a|=m\le|b|=n$, хотим посмотреть является ли a подстрокой b.}
\\Обзовем b(i)=$b_i b_{i+1}...b_{i+m-1}$, если отождествить их с числами, получим $b(i)=\frac{b(i-1)-b_{i-1}}{2}+2^{m-1} b_{i+m-1}$, посчитаем $\{b(i)\}_{0\le i\le n-m}$. Теперь посравниваем $a$ с получившимися b-шками по модулю случайного $p$, как в предыдущем алгоритме, но возьмем $\tau=(n^2m)\log(n^2m)$, $P_{\text{ошибки}}\le\frac{n}{\frac{\tau}{\log\tau}}\le\frac{2}{n^2}=O(\frac{1}{n^2})$, если $a=b(i)$, проверим руками равенство данной подстроки и $a$, теперь вероятность ошибки равна нулю. Посмотрим за сколько наш алгоритм работает. Если выключить ручную перепроверку, очев, будет $O(n)$, так как мы за $O(m)$ посчитаем $\{b(i)\}$ и $n-m+1$ раз проведем сравнение $b(i)$ и $a$. Есть включить, то <это я напишу когда-нибудь, когда пойму, что написано в конспекте Гирша(никогда)>.