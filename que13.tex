\section{Вероятностный алгоритм для сравнения строк на расстоянии и алгоритм Рабина-Карпа}

\secauthor{\ivan, \denis}
\subsection{Вероятностный алгоритм для сравнения строк <<на расстоянии>>}

\textbf{NB: }под <<на расстоянии>> имеется в виду, что две длинные строки хранятся на двух разных компьютерах; мы хотим передать как можно меньше битов между участником, у которого первая строка, и другим участником, у кого вторая строка.

Есть две строчки $a$ и $b$ длины $n$ над $\{0;1\}$, хотим их сравнить. Пусть $\tau$ -- параметр, который мы определим позже. Выберем равновероятно случайное простое число $p$ от 3 до $\tau$ (как-нибудь, неважно). Сравним остатки ($a$ и $b$ отождествим с числами, записью которых в двоичной системе счисления они являются) от деления на $p$. Если остатки совпали, то ответим <<строки одинаковые>>, иначе~-- <<строки разные>>.

Если остатки разные, то строки гарантированно разные. Вероятность ошибки (для случайно выбранного $p$ получилось $a\neq b,$ но $a\mod{p}=b\mod{p}$) выводится из следующих двух утверждений.

\begin{lemma*}
У числа $k\le 2^n$ меньше n различных простых делителей (очевидно). \qed
\end{lemma*}

Ясно, что $a-b\le 2^n$, следовательно, существует не более $n$ простых чисел, делящих $(a-b)$.

\begin{theorem*}[PNT, ослабленная версия]
Пусть $\pi(\tau)$~-- количество простых чисел на интервале $[1, \tau]$. Тогда
$$\pi(\tau) \sim \frac{\tau}{\log\tau}, \; \tau\rightarrow\infty.$$ \qed
\end{theorem*}

Так как $p$ выбрано равновероятно среди простых чисел интервала $\{3, \ldots, \tau\}$, имеем: $$P_{\text{ошибки}}\le\frac{n}{\pi(\tau)} \sim \frac{n\log\tau}{\tau}.$$

Добъемся хорошей оценки на вероятность ошибки: положим $\tau = n^2 \log n$. Тогда:
$$\frac{n\log\tau}{\tau} = \frac{n\log(n^2\log n)}{n^2\log n} = \frac{n(2\log n + O(\log n))}{n^2\log n} = O\left(\frac{1}{n}\right).$$

Следовательно, $P_\text{ошибки} = O\left(\frac{1}{n}\right)$.

Коли сравнивать мы будем числа по модулю $p$, нам потребуется только $O(\log p) = \\ O(\log(n^2\log n)) = O(\log n)$ памяти на хранение двух остатков.

\subsection{Алгоритм Рабина-Карпа для поиска подстроки в строке}

Есть две строчки, $|a|=m\le|b|=n$, хотим выяснить, является ли $a$ подстрокой $b$.

Обзовем $b(i)=b_i b_{i+1}...b_{i+m-1}$, если отождествить их с числами, получим $b(i)=\frac{b(i-1)-b_{i-1}}{2}+2^{m-1} b_{i+m-1}$. Посчитаем $\{b(i)\}_{0\le i\le n-m}$ за $O(n)$. Теперь посравниваем $a$ с получившимися $b$-шками по модулю случайного $p$, как в предыдущем алгоритме, но возьмем $\tau=(n^2m)\log(n^2m)$. Можно проверить, что тогда $P_{\text{ошибки}}\le\frac{n}{\frac{\tau}{\log\tau}}\le\frac{2}{n^2}=O(\frac{1}{n^2})$. Но мы \textbf{уберем вероятность ошибки вообще}: если $a\mod{p}=b(i)\mod{p}$, но при этом вхождение не найдено (т.е. $a\neq b(i)$ --- случилась \emph{коллизия}), то мы прервем работу алгоритма, и начнем простой посимвольный поиск $a$ в $b$ за время $O(mn)$.

Посмотрим, за сколько наш алгоритм работает (без ошибки). Все $b(i)$ и $a$ посчитаны вместе за $O(m+n)$ шагов, все сравнения $a \mod{p}$ с $b(i)$ стоят вместе $O(n)$ шагов. Вероятность ошибки при одной проверке $O\left(\frac{1}{n^2}\right)$, а вероятность хотя бы одной ошибки среди всех $n-m+1 = O(n)$ проверок~-- $O\left(\frac{1}{n}\right)$. Ручная проверка работает за $O(mn)$.

Итого: $$\mathbb E T\le O(m+n) + O(n) + O\left(\frac{1}{n}\right)\cdot O(mn) = O(m+n).$$
